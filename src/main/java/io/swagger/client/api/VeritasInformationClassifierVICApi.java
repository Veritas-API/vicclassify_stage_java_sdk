/*
 * Veritas Information Classifier (VIC)
 * APIs
 *
 * OpenAPI spec version: Resource Specific
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.ClassificationResultCollection;
import io.swagger.client.model.ErrorResponse;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class VeritasInformationClassifierVICApi {
    private ApiClient apiClient;

    public VeritasInformationClassifierVICApi() {
        this(Configuration.getDefaultApiClient());
    }

    public VeritasInformationClassifierVICApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for classify */
    private com.squareup.okhttp.Call classifyCall(String tenantId, List<String> policyId, String policy, List<String> metadata, String metadataFile, String documentName, Boolean includeMatches, Integer maxContentMatchesPerRule, Boolean skipTextExtraction, Boolean skipWhitespaceCollapse, File file, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/classify".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (tenantId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "tenantId", tenantId));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        if (policyId != null)
        localVarFormParams.put("policyId", policyId);
        if (policy != null)
        localVarFormParams.put("policy", policy);
        if (metadata != null)
        localVarFormParams.put("metadata", metadata);
        if (metadataFile != null)
        localVarFormParams.put("metadataFile", metadataFile);
        if (documentName != null)
        localVarFormParams.put("documentName", documentName);
        if (includeMatches != null)
        localVarFormParams.put("includeMatches", includeMatches);
        if (maxContentMatchesPerRule != null)
        localVarFormParams.put("maxContentMatchesPerRule", maxContentMatchesPerRule);
        if (skipTextExtraction != null)
        localVarFormParams.put("skipTextExtraction", skipTextExtraction);
        if (skipWhitespaceCollapse != null)
        localVarFormParams.put("skipWhitespaceCollapse", skipWhitespaceCollapse);
        if (file != null)
        localVarFormParams.put("file", file);

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "Bearer" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call classifyValidateBeforeCall(String tenantId, List<String> policyId, String policy, List<String> metadata, String metadataFile, String documentName, Boolean includeMatches, Integer maxContentMatchesPerRule, Boolean skipTextExtraction, Boolean skipWhitespaceCollapse, File file, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        
        com.squareup.okhttp.Call call = classifyCall(tenantId, policyId, policy, metadata, metadataFile, documentName, includeMatches, maxContentMatchesPerRule, skipTextExtraction, skipWhitespaceCollapse, file, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Determine a document&#39;s classification(s)
     * Classify a document using the specified policies or the tenant&#39;s default policies.   The document can be supplied by value (a stream of bytes) or by reference (a file path).  The document is automatically converted to text where required.   The classification results include the policies matched and suggested classification &#39;tags&#39; that the caller may associate with the content.  Extra information can optionally be returned giving more details about the content that triggered the classification - this reduces performance but is useful for diagnostics.
     * @param tenantId The tenant identifier (optional)
     * @param policyId One or more policies to use for the classification.  If not specified (and the &#39;policy&#39; parameter is not specified), the tenant&#39;s default policies are used. (optional)
     * @param policy A policy to use for the classification (json).  Normally the policies are specified by policyId, which is a reference to a stored policy.  However this option allows a policy to be supplied by value, which is useful (for example) for testing policies before storing them. (optional)
     * @param metadata One or more items of document metadata to use for classification (along with any content provided).   Each item of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.   Note that tools such as Swagger may send each field/value pair as a separate form part, but this is not necessary. It is more efficient to send each pair LF-delimited in a single form part. (optional)
     * @param metadataFile Full path to text file containing metadata to use for classification.  Each piece of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.  Multiple items of metadata are separated by a line feed (or CRLF). Multi-valued metadata must be specified as separate field/value pairs, for example recp:Sue\\nrecp:Bob.  The text MUST be UTF-8 or UTF-16LE.  The file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param documentName The document name and extension or full path. If known should include at least name and/or . prefixed extension.   If not supplying the document content in the request body then the document&#39;s full and accessible path is required. (optional)
     * @param includeMatches If true, the response contains details about the document matches used to determine the classification.  This may have a significant impact on classification performance. (optional)
     * @param maxContentMatchesPerRule The maximum number of content matches to include in the match details.   Only relevant if includeMatches is true.   This setting does not affect classification - it only affects the verbosity of the match information returned with the results. (optional)
     * @param skipTextExtraction If true, the content to classify is assumed to be text and no text extraction is performed.   **This optimization should only be used when the client is sure that the content is text.**   The text MUST be UTF-8 or UTF-16LE. If the content is specified by reference to a file, the file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param skipWhitespaceCollapse If true, the content to classify does not have its whitespace collapsed before classification.   **This optimization should only be used when the client is sure that whitespace has already been collapsed.**   Whitespace collapsing means that all sequences or two or more whitespace characters are replaced by a single space character.   This flag is only valid is skipTextExtraction is true. (optional)
     * @param file The document&#39;s binary or text content. Optional when documentName is the document&#39;s full and accessible path.   If multiple files are specified, the first is considered the primary document and the remaining files as attachments. (optional)
     * @return ClassificationResultCollection
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ClassificationResultCollection classify(String tenantId, List<String> policyId, String policy, List<String> metadata, String metadataFile, String documentName, Boolean includeMatches, Integer maxContentMatchesPerRule, Boolean skipTextExtraction, Boolean skipWhitespaceCollapse, File file) throws ApiException {
        ApiResponse<ClassificationResultCollection> resp = classifyWithHttpInfo(tenantId, policyId, policy, metadata, metadataFile, documentName, includeMatches, maxContentMatchesPerRule, skipTextExtraction, skipWhitespaceCollapse, file);
        return resp.getData();
    }

    /**
     * Determine a document&#39;s classification(s)
     * Classify a document using the specified policies or the tenant&#39;s default policies.   The document can be supplied by value (a stream of bytes) or by reference (a file path).  The document is automatically converted to text where required.   The classification results include the policies matched and suggested classification &#39;tags&#39; that the caller may associate with the content.  Extra information can optionally be returned giving more details about the content that triggered the classification - this reduces performance but is useful for diagnostics.
     * @param tenantId The tenant identifier (optional)
     * @param policyId One or more policies to use for the classification.  If not specified (and the &#39;policy&#39; parameter is not specified), the tenant&#39;s default policies are used. (optional)
     * @param policy A policy to use for the classification (json).  Normally the policies are specified by policyId, which is a reference to a stored policy.  However this option allows a policy to be supplied by value, which is useful (for example) for testing policies before storing them. (optional)
     * @param metadata One or more items of document metadata to use for classification (along with any content provided).   Each item of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.   Note that tools such as Swagger may send each field/value pair as a separate form part, but this is not necessary. It is more efficient to send each pair LF-delimited in a single form part. (optional)
     * @param metadataFile Full path to text file containing metadata to use for classification.  Each piece of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.  Multiple items of metadata are separated by a line feed (or CRLF). Multi-valued metadata must be specified as separate field/value pairs, for example recp:Sue\\nrecp:Bob.  The text MUST be UTF-8 or UTF-16LE.  The file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param documentName The document name and extension or full path. If known should include at least name and/or . prefixed extension.   If not supplying the document content in the request body then the document&#39;s full and accessible path is required. (optional)
     * @param includeMatches If true, the response contains details about the document matches used to determine the classification.  This may have a significant impact on classification performance. (optional)
     * @param maxContentMatchesPerRule The maximum number of content matches to include in the match details.   Only relevant if includeMatches is true.   This setting does not affect classification - it only affects the verbosity of the match information returned with the results. (optional)
     * @param skipTextExtraction If true, the content to classify is assumed to be text and no text extraction is performed.   **This optimization should only be used when the client is sure that the content is text.**   The text MUST be UTF-8 or UTF-16LE. If the content is specified by reference to a file, the file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param skipWhitespaceCollapse If true, the content to classify does not have its whitespace collapsed before classification.   **This optimization should only be used when the client is sure that whitespace has already been collapsed.**   Whitespace collapsing means that all sequences or two or more whitespace characters are replaced by a single space character.   This flag is only valid is skipTextExtraction is true. (optional)
     * @param file The document&#39;s binary or text content. Optional when documentName is the document&#39;s full and accessible path.   If multiple files are specified, the first is considered the primary document and the remaining files as attachments. (optional)
     * @return ApiResponse&lt;ClassificationResultCollection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<ClassificationResultCollection> classifyWithHttpInfo(String tenantId, List<String> policyId, String policy, List<String> metadata, String metadataFile, String documentName, Boolean includeMatches, Integer maxContentMatchesPerRule, Boolean skipTextExtraction, Boolean skipWhitespaceCollapse, File file) throws ApiException {
        com.squareup.okhttp.Call call = classifyValidateBeforeCall(tenantId, policyId, policy, metadata, metadataFile, documentName, includeMatches, maxContentMatchesPerRule, skipTextExtraction, skipWhitespaceCollapse, file, null, null);
        Type localVarReturnType = new TypeToken<ClassificationResultCollection>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Determine a document&#39;s classification(s) (asynchronously)
     * Classify a document using the specified policies or the tenant&#39;s default policies.   The document can be supplied by value (a stream of bytes) or by reference (a file path).  The document is automatically converted to text where required.   The classification results include the policies matched and suggested classification &#39;tags&#39; that the caller may associate with the content.  Extra information can optionally be returned giving more details about the content that triggered the classification - this reduces performance but is useful for diagnostics.
     * @param tenantId The tenant identifier (optional)
     * @param policyId One or more policies to use for the classification.  If not specified (and the &#39;policy&#39; parameter is not specified), the tenant&#39;s default policies are used. (optional)
     * @param policy A policy to use for the classification (json).  Normally the policies are specified by policyId, which is a reference to a stored policy.  However this option allows a policy to be supplied by value, which is useful (for example) for testing policies before storing them. (optional)
     * @param metadata One or more items of document metadata to use for classification (along with any content provided).   Each item of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.   Note that tools such as Swagger may send each field/value pair as a separate form part, but this is not necessary. It is more efficient to send each pair LF-delimited in a single form part. (optional)
     * @param metadataFile Full path to text file containing metadata to use for classification.  Each piece of metadata is specified as a field/value pair separated by a colon, for example auth:Sue Bloggs.  Multiple items of metadata are separated by a line feed (or CRLF). Multi-valued metadata must be specified as separate field/value pairs, for example recp:Sue\\nrecp:Bob.  The text MUST be UTF-8 or UTF-16LE.  The file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param documentName The document name and extension or full path. If known should include at least name and/or . prefixed extension.   If not supplying the document content in the request body then the document&#39;s full and accessible path is required. (optional)
     * @param includeMatches If true, the response contains details about the document matches used to determine the classification.  This may have a significant impact on classification performance. (optional)
     * @param maxContentMatchesPerRule The maximum number of content matches to include in the match details.   Only relevant if includeMatches is true.   This setting does not affect classification - it only affects the verbosity of the match information returned with the results. (optional)
     * @param skipTextExtraction If true, the content to classify is assumed to be text and no text extraction is performed.   **This optimization should only be used when the client is sure that the content is text.**   The text MUST be UTF-8 or UTF-16LE. If the content is specified by reference to a file, the file SHOULD have a byte order mark indicating the encoding.  If the encoding cannot be determined, UTF-8 is assumed. (optional)
     * @param skipWhitespaceCollapse If true, the content to classify does not have its whitespace collapsed before classification.   **This optimization should only be used when the client is sure that whitespace has already been collapsed.**   Whitespace collapsing means that all sequences or two or more whitespace characters are replaced by a single space character.   This flag is only valid is skipTextExtraction is true. (optional)
     * @param file The document&#39;s binary or text content. Optional when documentName is the document&#39;s full and accessible path.   If multiple files are specified, the first is considered the primary document and the remaining files as attachments. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call classifyAsync(String tenantId, List<String> policyId, String policy, List<String> metadata, String metadataFile, String documentName, Boolean includeMatches, Integer maxContentMatchesPerRule, Boolean skipTextExtraction, Boolean skipWhitespaceCollapse, File file, final ApiCallback<ClassificationResultCollection> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = classifyValidateBeforeCall(tenantId, policyId, policy, metadata, metadataFile, documentName, includeMatches, maxContentMatchesPerRule, skipTextExtraction, skipWhitespaceCollapse, file, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<ClassificationResultCollection>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
